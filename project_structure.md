# プロジェクト構造

## ディレクトリ構造
```
.
  ├── LICENSE
  ├── README.md
  ├── pyproject.toml
  ├── requirements-dev.lock
  ├── requirements.lock
  ├── run.py
  ├── script.py
  └── src/
    └── prism/
      ├── __init__.py
      ├── claude.py
      ├── config.py
      ├── db.py
      ├── routes.py
      └── static/
        └── js/
          ├── camera.js
          ├── cursor.js
          ├── edge.js
          ├── graph3d.js
          ├── node.js
          ├── plane.js
        └── css/
          ├── style.css
      └── templates/
        ├── base.html
```

## ファイル内容

### LICENSE
```
The MIT License (MIT)

Copyright (c) 2024 JPHACKS

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


```

### README.md
```
# サンプル（プロダクト名）

[![IMAGE ALT TEXT HERE](https://jphacks.com/wp-content/uploads/2024/07/JPHACKS2024_ogp.jpg)](https://www.youtube.com/watch?v=DZXUkEj-CSI)

## 製品概要
### 背景(製品開発のきっかけ、課題等）
### 製品説明（具体的な製品の説明）
### 特長
#### 1. 特長1
#### 2. 特長2
#### 3. 特長3

### 解決出来ること
### 今後の展望
### 注力したこと（こだわり等）
* 
* 

## 開発技術
### 活用した技術
#### API・データ
* 
* 

#### フレームワーク・ライブラリ・モジュール
* 
* 

#### デバイス
* 
* 

### 独自技術
#### ハッカソンで開発した独自機能・技術
* 独自で開発したものの内容をこちらに記載してください
* 特に力を入れた部分をファイルリンク、またはcommit_idを記載してください。

```

### pyproject.toml
```toml
[project]
name = "prism"
version = "0.1.0"
description = "Add your description here"
authors = [
    { name = "arugo11", email = "al23088@shibaura-it.ac.jp" }
]
dependencies = [
    "pymongo[srv]>=4.10.1",
    "flask>=3.0.3",
    "python-dotenv>=1.0.1",
    "anthropic>=0.37.1",
]
readme = "README.md"
requires-python = ">= 3.12"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.rye]
managed = true
dev-dependencies = []

[tool.hatch.metadata]
allow-direct-references = true

[tool.hatch.build.targets.wheel]
packages = ["src/prism"]

```

### requirements-dev.lock
```
# generated by rye
# use `rye lock` or `rye sync` to update this lockfile
#
# last locked with the following flags:
#   pre: false
#   features: []
#   all-features: false
#   with-sources: false
#   generate-hashes: false
#   universal: false

-e file:.
annotated-types==0.7.0
    # via pydantic
anthropic==0.37.1
    # via prism
anyio==4.6.2.post1
    # via anthropic
    # via httpx
blinker==1.8.2
    # via flask
certifi==2024.8.30
    # via httpcore
    # via httpx
    # via requests
charset-normalizer==3.4.0
    # via requests
click==8.1.7
    # via flask
distro==1.9.0
    # via anthropic
dnspython==2.7.0
    # via pymongo
filelock==3.16.1
    # via huggingface-hub
flask==3.0.3
    # via prism
fsspec==2024.10.0
    # via huggingface-hub
h11==0.14.0
    # via httpcore
httpcore==1.0.6
    # via httpx
httpx==0.27.2
    # via anthropic
huggingface-hub==0.26.1
    # via tokenizers
idna==3.10
    # via anyio
    # via httpx
    # via requests
itsdangerous==2.2.0
    # via flask
jinja2==3.1.4
    # via flask
jiter==0.6.1
    # via anthropic
markupsafe==3.0.2
    # via jinja2
    # via werkzeug
packaging==24.1
    # via huggingface-hub
pydantic==2.9.2
    # via anthropic
pydantic-core==2.23.4
    # via pydantic
pymongo==4.10.1
    # via prism
python-dotenv==1.0.1
    # via prism
pyyaml==6.0.2
    # via huggingface-hub
requests==2.32.3
    # via huggingface-hub
sniffio==1.3.1
    # via anthropic
    # via anyio
    # via httpx
tokenizers==0.20.1
    # via anthropic
tqdm==4.66.5
    # via huggingface-hub
typing-extensions==4.12.2
    # via anthropic
    # via huggingface-hub
    # via pydantic
    # via pydantic-core
urllib3==2.2.3
    # via requests
werkzeug==3.0.5
    # via flask

```

### requirements.lock
```
# generated by rye
# use `rye lock` or `rye sync` to update this lockfile
#
# last locked with the following flags:
#   pre: false
#   features: []
#   all-features: false
#   with-sources: false
#   generate-hashes: false
#   universal: false

-e file:.
annotated-types==0.7.0
    # via pydantic
anthropic==0.37.1
    # via prism
anyio==4.6.2.post1
    # via anthropic
    # via httpx
blinker==1.8.2
    # via flask
certifi==2024.8.30
    # via httpcore
    # via httpx
    # via requests
charset-normalizer==3.4.0
    # via requests
click==8.1.7
    # via flask
distro==1.9.0
    # via anthropic
dnspython==2.7.0
    # via pymongo
filelock==3.16.1
    # via huggingface-hub
flask==3.0.3
    # via prism
fsspec==2024.10.0
    # via huggingface-hub
h11==0.14.0
    # via httpcore
httpcore==1.0.6
    # via httpx
httpx==0.27.2
    # via anthropic
huggingface-hub==0.26.1
    # via tokenizers
idna==3.10
    # via anyio
    # via httpx
    # via requests
itsdangerous==2.2.0
    # via flask
jinja2==3.1.4
    # via flask
jiter==0.6.1
    # via anthropic
markupsafe==3.0.2
    # via jinja2
    # via werkzeug
packaging==24.1
    # via huggingface-hub
pydantic==2.9.2
    # via anthropic
pydantic-core==2.23.4
    # via pydantic
pymongo==4.10.1
    # via prism
python-dotenv==1.0.1
    # via prism
pyyaml==6.0.2
    # via huggingface-hub
requests==2.32.3
    # via huggingface-hub
sniffio==1.3.1
    # via anthropic
    # via anyio
    # via httpx
tokenizers==0.20.1
    # via anthropic
tqdm==4.66.5
    # via huggingface-hub
typing-extensions==4.12.2
    # via anthropic
    # via huggingface-hub
    # via pydantic
    # via pydantic-core
urllib3==2.2.3
    # via requests
werkzeug==3.0.5
    # via flask

```

### run.py
```python
#run.py
from src.prism  import create_app

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)
```

### script.py
```python
import os
import argparse
from pathlib import Path
import sys

def get_file_extension(file_path):
    """ファイル拡張子を取得する"""
    return os.path.splitext(file_path)[1].lower()

def is_source_code_file(file_path):
    """ソースコードファイルかどうかを判定"""
    code_extensions = {
        # バックエンド
        '.py',    # Python
        '.rb',    # Ruby
        '.php',   # PHP
        '.java',  # Java
        '.go',    # Go
        
        # フロントエンド
        '.js',    # JavaScript
        '.jsx',   # React
        '.ts',    # TypeScript
        '.tsx',   # React with TypeScript
        '.vue',   # Vue
        '.html',  # HTML
        '.htm',   # HTML
        '.css',   # CSS
        '.scss',  # SASS
        '.sass',  # SASS
        '.less',  # LESS
        
        # 設定ファイル
        '.json',  # JSON
        '.yaml',  # YAML
        '.yml',   # YAML
        '.toml',  # TOML
        '.xml',   # XML
        '.ini',   # INI
        '.env',   # Environment
    }
    return get_file_extension(file_path) in code_extensions

def is_config_file(file_name):
    """設定ファイルかどうかを判定"""
    config_files = {
        'requirements.txt',
        'requirements.lock',
        'requirements-dev.lock',
        'package.json',
        'package-lock.json',
        'composer.json',
        'composer.lock',
        'Gemfile',
        'Gemfile.lock',
        'pyproject.toml',
        'setup.py',
        'setup.cfg',
        'tsconfig.json',
        'webpack.config.js',
        'babel.config.js',
        '.babelrc',
        '.eslintrc',
        'vite.config.js',
        'README.md',
        'LICENSE',
    }
    return file_name in config_files

def is_important_file(file_path):
    """プロジェクトの構造理解に重要なファイルかどうかを判定"""
    file_name = file_path.name
    
    # 設定ファイルの場合
    if is_config_file(file_name):
        return True
    
    # ソースコードファイルの場合
    if is_source_code_file(file_path):
        # 特定のパターンを除外
        exclude_patterns = {
            'test_', 
            'tests.',
            'setup.',
            'conftest.',
            '.min.js',
            '.min.css',
        }
        return not any(pattern in str(file_path) for pattern in exclude_patterns)
    
    return False

def should_ignore_file(file_path):
    """無視すべきファイルかどうかを判定"""
    ignore_patterns = {
        '.Zone.Identifier',  # Windowsのゾーン識別子
        '.pyc',             # Pythonコンパイル済み
        '.pyo',             # Python最適化済み
        '.pyd',             # Python動的ライブラリ
        '.DS_Store',        # macOS
        '~',                # バックアップ
        '.bak',            # バックアップ
        '.tmp',            # 一時ファイル
        '.swp',            # Vim
        '.map',            # ソースマップ
        '.d.ts',           # TypeScript型定義
    }
    return any(pattern in str(file_path) for pattern in ignore_patterns)

def should_ignore_directory(dir_name):
    """無視すべきディレクトリかどうかを判定"""
    ignore_dirs = {
        '__pycache__',
        '.git',
        '.venv',
        'venv',
        'env',
        'node_modules',
        'vendor',
        'dist',
        'build',
        '.idea',
        '.vscode',
        '.pytest_cache',
        '.mypy_cache',
        'coverage',
        '.next',
        '.nuxt',
        'public',
        '.husky',
    }
    return dir_name in ignore_dirs

def get_language_marker(file_path):
    """ファイルの言語に応じたマークダウンマーカーを取得"""
    ext = get_file_extension(file_path)
    markers = {
        '.py': 'python',
        '.js': 'javascript',
        '.jsx': 'jsx',
        '.ts': 'typescript',
        '.tsx': 'tsx',
        '.html': 'html',
        '.css': 'css',
        '.scss': 'scss',
        '.sass': 'sass',
        '.json': 'json',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        '.toml': 'toml',
        '.xml': 'xml',
    }
    return markers.get(ext, '')

def read_file_content(file_path):
    """ファイルの内容を読み込む"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        try:
            with open(file_path, 'r', encoding='shift-jis') as f:
                return f.read()
        except:
            return f"Error: Could not read file {file_path}"

def get_file_size(file_path):
    """ファイルサイズを取得（KB）"""
    return os.path.getsize(file_path) / 1024

def process_directory(directory_path, output_file, max_file_size_kb=1000):
    """プロジェクトの重要なファイルを処理"""
    directory_path = Path(directory_path)
    all_files = []
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# プロジェクト構造\n\n")
        
        # ディレクトリ構造の出力
        f.write("## ディレクトリ構造\n```\n")
        for root, dirs, files in os.walk(directory_path):
            # 不要なディレクトリをスキップ
            dirs[:] = [d for d in dirs if not should_ignore_directory(d)]
            
            level = root.replace(str(directory_path), '').count(os.sep)
            indent = '  ' * level
            base_name = os.path.basename(root)
            
            if level == 0:
                f.write(".\n")
            else:
                f.write(f"{indent}└── {base_name}/\n")
            
            subindent = '  ' * (level + 1)
            for file in sorted(files):
                file_path = Path(root) / file
                if is_important_file(file_path) and not should_ignore_file(file_path):
                    f.write(f"{subindent}├── {file}\n")
                    all_files.append(file_path)
        
        f.write("```\n\n")
        
        # ファイル内容の出力
        f.write("## ファイル内容\n\n")
        
        # まず設定ファイルを出力
        config_files = [f for f in all_files if is_config_file(f.name)]
        for file_path in sorted(config_files):
            size_kb = get_file_size(file_path)
            if size_kb <= max_file_size_kb:
                relative_path = file_path.relative_to(directory_path)
                f.write(f"### {relative_path}\n")
                f.write(f"```{get_language_marker(file_path)}\n")
                f.write(read_file_content(file_path))
                f.write("\n```\n\n")
            else:
                f.write(f"### {relative_path} (サイズが大きいためスキップ: {size_kb:.1f}KB)\n\n")
        
        # 次にソースコードファイルを出力
        source_files = [f for f in all_files if is_source_code_file(f) and not is_config_file(f.name)]
        for file_path in sorted(source_files):
            size_kb = get_file_size(file_path)
            if size_kb <= max_file_size_kb:
                relative_path = file_path.relative_to(directory_path)
                f.write(f"### {relative_path}\n")
                f.write(f"```{get_language_marker(file_path)}\n")
                f.write(read_file_content(file_path))
                f.write("\n```\n\n")
            else:
                f.write(f"### {relative_path} (サイズが大きいためスキップ: {size_kb:.1f}KB)\n\n")

def main():
    parser = argparse.ArgumentParser(description='プロジェクトのソースコードを抽出してファイルに出力するツール')
    parser.add_argument('directory', nargs='?', default='.', 
                       help='処理するディレクトリのパス（デフォルト: カレントディレクトリ）')
    parser.add_argument('--output', '-o', default='project_structure.md',
                       help='出力ファイル名（デフォルト: project_structure.md）')
    parser.add_argument('--max-size', '-m', type=float, default=1000,
                       help='処理する最大ファイルサイズ（KB）（デフォルト: 1000KB）')
    args = parser.parse_args()

    try:
        process_directory(args.directory, args.output, args.max_size)
        print(f"処理が完了しました。結果は {args.output} に保存されています。")
    except Exception as e:
        print(f"エラーが発生しました: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### src/prism/__init__.py
```python
# src/prism/__init__.py
from flask import Flask
from .config import Config
from .routes import main

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    

    app.register_blueprint(main)
    
    return app
```

### src/prism/claude.py
```python
# src/prism/claude.py
import anthropic
from flask import current_app
import json
from math import pi, cos, sin

def analyze_text(text : str):
    """claudeAPIを使用しテキストを解析してグラフデータを作成

    引数:
        text (str): 入力された文字列
    """

    client = anthropic.Anthropic(
        api_key=current_app.config['CLAUDE_API_KEY']
    )

    #プロンプト
    prompt = f"""
入力されたニュース記事から、政治に関連する政策と人物、およびその関係性を抽出し、3D可視化用のJSONデータを生成してください。

【要件】
1. 政策ノード
   - 記事内で言及される具体的な政策や法案
   - 政策の概要説明（140文字以内）

2. 人物ノード
   - 記事内で言及される政治家や関係者
   - 人物の説明（140文字以内）

3. 抽出ルール
   - 政策と人物の関係性が明確な場合のみ抽出
   - 不明確な関係性は推測せず、抽出しない
   - 政治と関係のない記事の場合は抽出失敗とする

【出力形式】
以下の形式のJSONデータのみを出力してください：
{{
  "nodes": [
    {{
      "id": "一意のID",
      "type": "policy" or "person",
      "name": "政策名または人物名",
      "description": "140文字以内の説明",
      "position": {{"x": 0, "y": 0, "z": 0}}
    }}
  ],
  "edges": [
    {{
      "source": "ノードID",
      "target": "ノードID",
      "label": "関係性の説明"
    }}
  ]
}}

入力テキスト：
{text}
"""

    # call claude API
    response = client.messages.create(
        model = current_app.config['CLAUDE_MODEL'],
        max_tokens = 2000,
        messages=[
            {
                "role" : "user",
                "content" : prompt
            }
        ]
    )

    try:
        # レスポンスからJSON形式で抽出
        response_text = response.content[0].text
        graph_data = json.loads(response_text)

        #ノードの位置を動的に設定
        for i, node in enumerate(graph_data['nodes']):
            angle = (2 * pi * i) / len(graph_data['nodes'])
            node['position'] = {
                'x' : 30 * cos(angle),
                'y' : 0,
                'z' : 30 * sin(angle)
            }

            return graph_data
    except Exception as e:
        current_app.logger.error(f"Error : Claude response{e}")
        return None
```

### src/prism/config.py
```python
#src/prism/config.py
import os
from dotenv import load_dotenv

load_dotenv('src/prism/config.setting')

class Config:
    #環境変数をブール値として解釈
    DEBUG = os.getenv("DEBUG","False").lower() in ('true', '1', 't')
    MONGODB = os.getenv('MONGODB_URI')
    CLAUDE_API_KEY = os.getenv('CLAUDE_API_KEY')
    CLAUDE_MODEL = os.getenv('CLAUDE_MODEL')

    REQUEST_TIMEOUT = 60
    MONGODB_TIMEOUT = 5
    CLAUDE_API_TIMEOUT = 30

```

### src/prism/db.py
```python
"""src/prism/db.py"""
from pymongo import MongoClient

def test_connection():
    # 接続文字
    uri = "mongodb+srv://Argo:Scenekawaii_11@cluster0.zrenn.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"

    try:
        # クライアントの作成
        client = MongoClient(uri)
        #pingコマンドで確認
        client.admin.command('ping')
        print("Success")
        return True
    except Exception as e:
        print(f"False : {e}")
        return False
    finally:
        client.close()

if __name__ == "__main__":
    test_connection()
```

### src/prism/routes.py
```python
#src/prism/routes.py
from flask  import Blueprint, render_template, jsonify, request
from .db    import test_connection
from .claude import analyze_text

main = Blueprint('main',__name__)

@main.route('/')
def index():
    return render_template('base.html')

@main.route('/api/test-db')
def test_db():
    success = test_connection()
    return jsonify({"success": success})

@main.route('/api/test-graph')
def test_graph():
    test_data = {
        "nodes": [
            {
                "id": "policy1",
                "type": "policy",
                "name": "デジタル社会推進法案",
                "description": "2024年度内の成立を目指す法案",
                "position": {"x": 0, "y": 0, "z": 0}
            },
            {
                "id": "person1",
                "type": "person",
                "name": "山田太郎",
                "description": "内閣総理大臣",
                "position": {"x": 30, "y": 0, "z": 30}
            },
            {
                "id": "policy2",
                "type": "policy",
                "name": "AI規制法案",
                "description": "AI開発に関する規制法案",
                "position": {"x": -30, "y": 0, "z": 30}
            },
            {
                "id": "person2",
                "type": "person",
                "name": "鈴木花子",
                "description": "デジタル大臣",
                "position": {"x": 0, "y": 0, "z": 60}
            }
        ],
        "edges": [
            {
                "source": "person1",
                "target": "policy1",
                "label": "提案"
            },
            {
                "source": "person2",
                "target": "policy1",
                "label": "推進"
            },
            {
                "source": "person2",
                "target": "policy2",
                "label": "担当"
            }
        ]
    }
    return jsonify(test_data)

@main.route('/api/analyze', methods = ['POST'])
def analyze():
    if not request.is_json:
        return jsonify({"error" : "コンテンツの形式はjson形式である必要があります"
                        }), 400
    text = request.json.get('text')
    if not text:
        return jsonify({"error" : "テキストが送信されていません"}), 400
    graph_data = analyze_text(text)
    if graph_data is None:
        # 処理中になんらかのエラーが発生してもこっちのエラーがでる、クライアントのせいだね
        return jsonify({"error" : """分析に失敗しました、
                        テキストは政治に関連する記事などのコピペである必要があります"""
                        }), 422
    return jsonify(graph_data)
```

### src/prism/static/css/style.css
```css
/*src/prism/static/css/style.css*/
body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    overflow: hidden;
}

#app {
    display: grid;
    grid-template-columns: 200px 1fr;
    grid-template-rows: 1fr auto;
    height: 100vh;
    background-color: #f5f5f5;
}

.side-menu {
    background: white;
    padding: 20px;
    border-right: 1px solid #e0e0e0;
    grid-row: 1 / -1;
}

.control-item {
    margin: 10px 0;
}

.control-item label {
    display: block;
    margin-bottom: 5px;
}

.control-item input[type="range"] {
    width: 100%;
}

#graph-container {
    position: relative;
    grid-column: 2;
    grid-row: 1;
}

#myCanvas {
    width: 100%;
    height: 100%;
}

.control-panel {
    position: absolute;
    top: 20px;
    right: 20px;
    background: white;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.input-area {
    grid-column: 2;
    grid-row: 2;
    padding: 10px;
    background: white;
    border-top: 1px solid #e0e0e0;
    display: flex;
    gap: 10px;
}

#text-input {
    flex: 1;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

#upload-btn {
    padding: 8px 16px;
    background: #2196F3;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#upload-btn:hover {
    background: #1976D2;
}
#graph-container {
    width: 100%;
    height: 100%;
    background: #ffffff;
}

#graph-container canvas {
    width: 100% !important;
    height: 100% !important;
}
```

### src/prism/static/js/camera.js
```javascript
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

// ページの読み込みを待つ
window.addEventListener("DOMContentLoaded", init);

function init() {
    // サイズを指定
    const width = window.innerWidth;
    const height = window.innerHeight;

    const canvasElement = document.querySelector("#myCanvas");
    // レンダラーを作成
    const renderer = new THREE.WebGLRenderer({
        canvas: canvasElement,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff);
    document.body.appendChild(renderer.domElement);

    // シーンを作成し、グローバル変数に保存
    const scene = new THREE.Scene();
    window.scene = scene;  // グローバル変数としてシーンを保存

    // カメラを作成
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.set(0, 100, 600);

    // カメラコントローラーを作成
    const controls = new OrbitControls(camera, canvasElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.2;

    tick();

    // 毎フレーム時に実行されるループイベントです
    function tick() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
    }
}

```

### src/prism/static/js/cursor.js
```javascript
// カーソル用のdivタグを取得してcursorに格納
var cursor = document.getElementById('cursor'); 

// カーソル用のdivタグをマウスに追従させる
document.addEventListener('mousemove', function (e) {
    cursor.style.transform = 'translate(' + e.clientX + 'px, ' + e.clientY + 'px)';
});

// リンクにホバーした時にクラス追加、離れたらクラス削除
var link = document.querySelectorAll('cs');
for (var i = 0; i < link.length; i++) {
    link[i].addEventListener('mouseover', function (e) {
        cursor.classList.add('cursor--hover');
    });
    link[i].addEventListener('mouseout', function (e) {
        cursor.classList.remove('cursor--hover');   
    });
}
```

### src/prism/static/js/edge.js
```javascript
export class Edge {
  constructor(scene, startNode, endNode, label, arrowThickness = 0.1) {
      this.scene = scene;
      this.startNode = startNode;
      this.endNode = endNode;
      this.label = label;  // ラベルを保持
      this.arrowThickness = arrowThickness;
      this.color = 0x9E9E9E; // グレー

      this.createArrow();
      if (this.label) {
          this.createLabel();  // ラベルがある場合は作成
      }
  }

  createArrow() {
      const startPos = this.startNode.getPosition();
      const endPos = this.endNode.getPosition();
      const direction = new THREE.Vector3().subVectors(endPos, startPos).normalize();
      const length = startPos.distanceTo(endPos);

      // 矢印の胴体
      const cylinderLength = length - 2;
      const cylinderGeometry = new THREE.CylinderGeometry(
          this.arrowThickness,
          this.arrowThickness,
          cylinderLength,
          12
      );
      const cylinderMaterial = new THREE.MeshPhongMaterial({
          color: this.color,
          transparent: true,
          opacity: 0.8
      });
      this.cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);

      // 位置と向きを設定
      this.cylinder.position.copy(startPos).add(direction.clone().multiplyScalar(cylinderLength / 2));
      this.cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);

      // 矢印の先端
      const coneGeometry = new THREE.ConeGeometry(this.arrowThickness * 2, 1, 12);
      const coneMaterial = new THREE.MeshPhongMaterial({
          color: this.color,
          transparent: true,
          opacity: 0.8
      });
      this.cone = new THREE.Mesh(coneGeometry, coneMaterial);

      // 先端の位置と向きを設定
      this.cone.position.copy(startPos).add(direction.clone().multiplyScalar(cylinderLength));
      this.cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);

      this.scene.add(this.cylinder);
      this.scene.add(this.cone);
  }

  createLabel() {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;

      // 背景を透明に
      context.clearRect(0, 0, canvas.width, canvas.height);

      // テキストを描画
      context.fillStyle = '#000000';
      context.font = `${document.getElementById('edge-label-size').value}px Arial`;
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(this.label, canvas.width/2, canvas.height/2);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true
      });
      this.labelSprite = new THREE.Sprite(spriteMaterial);

      // ラベルの位置を矢印の中央に配置
      const startPos = this.startNode.getPosition();
      const endPos = this.endNode.getPosition();
      this.labelSprite.position.lerpVectors(startPos, endPos, 0.5);
      this.labelSprite.position.y += 2;  // 少し上に配置
      
      // ラベルのサイズを設定
      const scale = document.getElementById('edge-label-size').value * 0.1;
      this.labelSprite.scale.set(scale * 5, scale * 2.5, 1);

      this.scene.add(this.labelSprite);
  }

  update() {
      this.scene.remove(this.cylinder);
      this.scene.remove(this.cone);
      if (this.labelSprite) {
          this.scene.remove(this.labelSprite);
      }
      this.createArrow();
      if (this.label) {
          this.createLabel();
      }
  }
}
```

### src/prism/static/js/graph3d.js
```javascript
// graph3d.js
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { Node } from './node.js';
import { Edge } from './edge.js';
import { GridPlane } from './plane.js';

class Graph3D {
    constructor() {
        this.initScene();
        this.initRenderer();
        this.initCamera();
        this.initLights();
        this.initGrid();
        
        // データ構造の初期化
        this.nodes = new Map();
        this.edges = [];
        
        // イベントリスナーとコントロールの設定
        this.setupEventListeners();
        this.setupControls();
        
        // 初期データの読み込みとアニメーション開始
        this.loadTestData();
        this.animate();
    }

    // シーンの初期化
    initScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xffffff);
    }

    // レンダラーの初期化
    initRenderer() {
        const container = document.getElementById('graph-container');
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(this.renderer.domElement);
    }

    // カメラの初期化
    initCamera() {
        const container = document.getElementById('graph-container');
        const aspect = container.clientWidth / container.clientHeight;
        this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
        this.camera.position.set(50, 50, 50);
        this.camera.lookAt(0, 0, 0);

        // OrbitControlsの設定
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.setupCameraControls();
    }

    // カメラコントロールの詳細設定
    setupCameraControls() {
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 30;
        this.controls.maxDistance = 200;
        this.controls.minPolarAngle = Math.PI / 6;
        this.controls.maxPolarAngle = Math.PI * 5/6;
    }

    // ライティングの初期化
    initLights() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        
        this.scene.add(ambientLight);
        this.scene.add(directionalLight);
    }

    // グリッドの初期化
    initGrid() {
        this.grid = new GridPlane(this.scene);
    }

    // イベントリスナーの設定
    setupEventListeners() {
        // ウィンドウリサイズ対応
        window.addEventListener('resize', this.handleResize.bind(this));

        // スライダーの値表示更新
        this.setupSliderListeners();

        // アップロードボタンの処理
        this.setupUploadListener();
    }

    // スライダーのイベントリスナー設定
    setupSliderListeners() {
        const sliders = document.querySelectorAll('input[type="range"]');
        sliders.forEach(slider => {
            const label = slider.previousElementSibling;
            const span = label.querySelector('span');
            slider.addEventListener('input', () => {
                span.textContent = slider.value;
            });
        });
    }

    // アップロードボタンのイベントリスナー設定
    setupUploadListener() {
        const uploadBtn = document.getElementById('upload-btn');
        uploadBtn.addEventListener('click', this.handleUpload.bind(this));
    }

    // ウィンドウリサイズハンドラ
    handleResize() {
        const container = document.getElementById('graph-container');
        this.camera.aspect = container.clientWidth / container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // アップロード処理
    async handleUpload() {
        const text = document.getElementById('text-input').value;
        if (!text) return;

        const button = document.getElementById('upload-btn');
        const originalText = button.textContent;
        button.disabled = true;
        button.textContent = '解析中...';

        try {
            const response = await fetch('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || '解析に失敗しました');
            }

            const data = await response.json();
            this.clearGraph();
            this.renderGraph(data);
        } catch (error) {
            console.error('Error analyzing text:', error);
            alert(error.message);
        } finally {
            button.disabled = false;
            button.textContent = originalText;
        }
    }

    // コントロールパネルの設定
    setupControls() {
        this.setupNodeControls();
        this.setupViewModeControl();
        this.setupEdgeControls();  // 追加
    }
    // エッジコントロールの設定
    setupEdgeControls() {
        document.getElementById('edge-size').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value) * 0.01;
            this.edges.forEach(edge => {
                edge.arrowThickness = size;
                edge.update();
            });
        });

        document.getElementById('edge-label-size').addEventListener('input', () => {
            this.edges.forEach(edge => {
                if (edge.label) {
                    edge.update();
                }
            });
        });
    }

    // ノードコントロールの設定
    setupNodeControls() {
        document.getElementById('node-size').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            this.nodes.forEach(node => node.setSize(size));
        });

        document.getElementById('text-size').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            this.nodes.forEach(node => node.setTextSize(size));
        });
    }

    // 表示モード切り替えの設定
    setupViewModeControl() {
        document.getElementById('view-mode').addEventListener('change', (e) => {
            if (e.target.value === '2d') {
                this.set2DView();
            } else {
                this.set3DView();
            }
        });
    }

    // 2Dビューの設定
    set2DView() {
        this.camera.position.set(0, 80, 0);
        this.camera.lookAt(0, 0, 0);
        this.controls.enableRotate = false;
    }

    // 3Dビューの設定
    set3DView() {
        this.camera.position.set(50, 50, 50);
        this.camera.lookAt(0, 0, 0);
        this.controls.enableRotate = true;
    }

    // グラフのクリア
    clearGraph() {
        this.nodes.forEach(node => {
            this.scene.remove(node.plane);
            this.scene.remove(node.outline);
            if (node.textSprite) this.scene.remove(node.textSprite);
        });
        
        this.edges.forEach(edge => {
            this.scene.remove(edge.cylinder);
            this.scene.remove(edge.cone);
            if (edge.labelSprite) this.scene.remove(edge.labelSprite);
        });
        
        this.nodes.clear();
        this.edges = [];
    }

    // アニメーションループ
    animate() {
        requestAnimationFrame(this.animate.bind(this));
        this.controls.update();
        this.nodes.forEach(node => node.update(this.camera));
        this.renderer.render(this.scene, this.camera);
    }

    // テストデータの読み込み
    async loadTestData() {
        try {
            const response = await fetch('/api/test-graph');
            const data = await response.json();
            this.renderGraph(data);
        } catch (error) {
            console.error('Error loading test data:', error);
        }
    }

    renderGraph(data) {
        // ノードの作成
        data.nodes.forEach(nodeData => {
            const node = new Node(this.scene, this.camera, nodeData);
            node.setPosition(nodeData.position.x, nodeData.position.y, nodeData.position.z);
            this.nodes.set(nodeData.id, node);
        });
    
        // エッジの作成
        data.edges.forEach(edgeData => {
            const startNode = this.nodes.get(edgeData.source);
            const endNode = this.nodes.get(edgeData.target);
            if (startNode && endNode) {
                // エッジ作成時にラベルと太さを渡す
                const edge = new Edge(
                    this.scene, 
                    startNode, 
                    endNode, 
                    edgeData.label,  // ラベルを渡す
                    document.getElementById('edge-size').value * 0.01  // 矢印の太さ
                );
                this.edges.push(edge);
            }
        });
    }
}

// アプリケーション初期化
document.addEventListener('DOMContentLoaded', () => new Graph3D());

export default Graph3D;
```

### src/prism/static/js/node.js
```javascript
//src/prism/static/js/node.js
import * as THREE from 'three';

export class Node {
  constructor(scene, camera, data, size = 1) {
    this.scene = scene;
    this.camera = camera;
    this.size = size;
    this.data = data;

    // ノードの色を設定（政策：緑、人物：青）
    const color = data.type === 'policy' ? 0x4CAF50 : 0x2196F3;

    // 四角形のジオメトリとマテリアルを作成
    const geometry = new THREE.PlaneGeometry(this.size * 2, this.size * 2);
    const material = new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.8
    });
    this.plane = new THREE.Mesh(geometry, material);

    // 枠線の追加
    const edges = new THREE.EdgesGeometry(geometry);
    this.outline = new THREE.LineSegments(
      edges,
      new THREE.LineBasicMaterial({ color: 0x000000 })
    );

    // テキストを作成
    this.createText();

    // シーンに追加
    this.scene.add(this.plane);
    this.scene.add(this.outline);
  }

  createText() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 128;

    // 背景を透明に
    context.fillStyle = 'rgba(255, 255, 255, 0)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // テキストを描画
    context.fillStyle = '#000000';
    context.font = 'bold 24px Arial';
    context.textAlign = 'center';
    context.fillText(this.data.name, canvas.width/2, canvas.height/2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    this.textSprite = new THREE.Sprite(spriteMaterial);
    this.textSprite.scale.set(5, 2.5, 1);
    
    this.scene.add(this.textSprite);
  }

  setPosition(x, y, z) {
    this.plane.position.set(x, y, z);
    this.outline.position.set(x, y, z);
    if (this.textSprite) {
      this.textSprite.position.set(x, y, z);
    }
  }

  setSize(newSize) {
    this.size = newSize;
    this.plane.scale.set(newSize, newSize, 1);
    this.outline.scale.set(newSize, newSize, 1);
    if (this.textSprite) {
      this.textSprite.scale.set(newSize * 5, newSize * 2.5, 1);
    }
  }

  getPosition() {
    return this.plane.position;
  }

  // カメラに向けてノードを回転
  update(camera) {
    this.plane.quaternion.copy(camera.quaternion);
    this.outline.quaternion.copy(camera.quaternion);
  }
}
```

### src/prism/static/js/plane.js
```javascript
//src/prism/static/js/plane.js
import * as THREE from 'three';
export class GridPlane {
  constructor(scene, size = 1000, divisions = 50) {
    // グリッドヘルパーを作成（白色）
    this.grid = new THREE.GridHelper(size, divisions, 0xCCCCCC, 0xCCCCCC);
    this.grid.position.y = -50;
    this.grid.material.opacity = 0.2;
    this.grid.material.transparent = true;

    // 平面を作成（白色）
    const planeGeometry = new THREE.PlaneGeometry(size, size);
    const planeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xFFFFFF, 
      side: THREE.DoubleSide 
    });
    this.plane = new THREE.Mesh(planeGeometry, planeMaterial);
    this.plane.rotation.x = -Math.PI / 2;
    this.plane.position.y = -50;

    // シーンに追加
    scene.add(this.grid);
    scene.add(this.plane);
  }
}
```

### src/prism/templates/base.html
```html
<!-- src/prism/templates/base.html-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>政治関連記事ビジュアライザー</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script async src="https://unpkg.com/es-module-shims/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
</head>
<body>
    <div id="app">
        <div class="side-menu">
            <h3>ノード</h3>
            <div class="control-item">
                <label>文字: <span>10</span>px</label>
                <input type="range" id="text-size" min="8" max="24" value="10">
            </div>
            <div class="control-item">
                <label>サイズ: <span>20</span>px</label>
                <input type="range" id="node-size" min="1" max="40" value="20">
            </div>
            <h3>エッジ</h3>
            <div class="control-item">
                <label>ラベル: <span>10</span>px</label>
                <input type="range" id="edge-label-size" min="8" max="24" value="10">
            </div>
            <div class="control-item">
                <label>矢印: <span>20</span>px</label>
                <input type="range" id="edge-size" min="1" max="40" value="20">
            </div>
        </div>

        <div id="graph-container"></div>

        <div class="control-panel">
            <select id="view-mode">
                <option value="3d">3D</option>
                <option value="2d">2D</option>
            </select>
        </div>

        <div class="input-area">
            <input type="text" id="text-input" placeholder="テキストを入力">
            <button id="upload-btn">アップロード</button>
        </div>
    </div>

    <script type="module" src="{{ url_for('static', filename='js/graph3d.js') }}"></script>
</body>
</html>
```

